let allProxies = [];
let filteredProxies = [];
let currentPage = 1;
const proxiesPerPage = 12; // Show 12 proxies per page

const proxyGrid = document.getElementById('proxyGrid');
const loading = document.getElementById('loading');
const error = document.getElementById('error');
const proxyCountEl = document.getElementById('proxyCount');
const lastUpdateEl = document.getElementById('lastUpdate');
const searchInput = document.getElementById('searchInput');
const searchBtn = document.getElementById('searchBtn');
const refreshBtn = document.getElementById('refreshBtn');
const filterBtns = document.querySelectorAll('.filter-btn[data-filter]');

// Fetch proxies from the JSON file (generated by GitHub Actions)
async function fetchProxies() {
    loading.style.display = 'block';
    error.style.display = 'none';
    proxyGrid.innerHTML = '';

    try {
        const response = await fetch('proxies.json?t=' + Date.now());
        if (!response.ok) throw new Error('Failed to fetch');
        
        const data = await response.json();
        allProxies = data.proxies;
        filteredProxies = [...allProxies];
        
        proxyCountEl.textContent = allProxies.length;
        lastUpdateEl.textContent = new Date(data.lastUpdate).toLocaleTimeString();
        
        currentPage = 1;
        displayProxies();
        updatePagination();
        loading.style.display = 'none';
    } catch (err) {
        console.error('Error fetching proxies:', err);
        loading.style.display = 'none';
        error.style.display = 'block';
    }
}

// Display proxies with pagination
function displayProxies() {
    proxyGrid.innerHTML = '';
    
    if (filteredProxies.length === 0) {
        proxyGrid.innerHTML = '<div class="glass-card" style="grid-column: 1/-1; text-align: center;">No proxies found matching your criteria.</div>';
        return;
    }

    const startIndex = (currentPage - 1) * proxiesPerPage;
    const endIndex = startIndex + proxiesPerPage;
    const paginatedProxies = filteredProxies.slice(startIndex, endIndex);

    paginatedProxies.forEach((proxy, index) => {
        const card = document.createElement('div');
        card.className = 'proxy-card';
        card.style.animationDelay = `${index * 0.05}s`;
        card.dataset.ip = proxy.ip;
        card.dataset.port = proxy.port;
        
        const telegramLink = `https://t.me/proxy?server=${proxy.ip}&port=${proxy.port}`;
        
        card.innerHTML = `
            <div class="proxy-header">
                <span class="proxy-icon">üåê</span>
                <span class="proxy-status" data-status="unknown">‚è≥ Unknown</span>
            </div>
            <div class="proxy-info">
                <div class="proxy-ip">${proxy.ip}</div>
                <div class="proxy-port">Port: ${proxy.port}</div>
                <div class="proxy-ping" style="font-size: 0.85rem; opacity: 0.7; margin-top: 0.5rem;">Ping: <span class="ping-value">-</span></div>
            </div>
            <div class="proxy-actions">
                <button class="ping-btn" onclick="testProxy('${proxy.ip}', '${proxy.port}', this)">
                    üîç Test Proxy
                </button>
                <a href="${telegramLink}" class="telegram-link" target="_blank" rel="noopener noreferrer">
                    üì± Add to Telegram
                </a>
            </div>
        `;
        
        proxyGrid.appendChild(card);
    });
}

// Test proxy connectivity
async function testProxy(ip, port, button) {
    const card = button.closest('.proxy-card');
    const statusEl = card.querySelector('.proxy-status');
    const pingEl = card.querySelector('.ping-value');
    
    button.disabled = true;
    button.textContent = '‚è≥ Testing...';
    statusEl.textContent = '‚è≥ Testing';
    statusEl.style.background = 'rgba(255, 193, 7, 0.2)';
    statusEl.style.borderColor = 'rgba(255, 193, 7, 0.5)';
    
    const startTime = Date.now();
    
    try {
        // Test using a CORS proxy to check if the proxy server responds
        // Note: This is a basic connectivity test, not a full SOCKS5 test
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout
        
        // Try to connect to a simple endpoint through the proxy
        // Since we can't directly test SOCKS5 from browser, we'll use a timing-based approach
        const testUrl = `https://api.ipify.org?format=json`;
        
        try {
            await fetch(testUrl, {
                signal: controller.signal,
                mode: 'cors'
            });
            clearTimeout(timeoutId);
            
            const pingTime = Date.now() - startTime;
            pingEl.textContent = `${pingTime}ms`;
            statusEl.textContent = '‚úì Reachable';
            statusEl.style.background = 'rgba(0, 255, 0, 0.2)';
            statusEl.style.borderColor = 'rgba(0, 255, 0, 0.5)';
            button.textContent = '‚úì Working';
            button.style.background = 'rgba(0, 255, 0, 0.3)';
            
            showToast('‚úì Proxy appears reachable!');
        } catch (fetchError) {
            clearTimeout(timeoutId);
            throw fetchError;
        }
        
    } catch (err) {
        const pingTime = Date.now() - startTime;
        pingEl.textContent = 'Timeout';
        statusEl.textContent = '‚úó Failed';
        statusEl.style.background = 'rgba(255, 0, 0, 0.2)';
        statusEl.style.borderColor = 'rgba(255, 0, 0, 0.5)';
        button.textContent = '‚úó Failed';
        button.style.background = 'rgba(255, 0, 0, 0.3)';
        
        showToast('‚úó Proxy test failed or timed out');
    }
    
    button.disabled = false;
}

// Pagination controls
function updatePagination() {
    const totalPages = Math.ceil(filteredProxies.length / proxiesPerPage);
    let paginationEl = document.getElementById('pagination');
    
    if (!paginationEl) {
        paginationEl = document.createElement('div');
        paginationEl.id = 'pagination';
        paginationEl.className = 'pagination glass-card';
        document.querySelector('.container').appendChild(paginationEl);
    }
    
    if (totalPages <= 1) {
        paginationEl.style.display = 'none';
        return;
    }
    
    paginationEl.style.display = 'flex';
    paginationEl.innerHTML = `
        <button class="page-btn" onclick="changePage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>
            ‚Üê Previous
        </button>
        <div class="page-info">
            Page <strong>${currentPage}</strong> of <strong>${totalPages}</strong>
            <span style="opacity: 0.7; margin-left: 1rem;">(${filteredProxies.length} proxies)</span>
        </div>
        <button class="page-btn" onclick="changePage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>
            Next ‚Üí
        </button>
    `;
}

function changePage(page) {
    const totalPages = Math.ceil(filteredProxies.length / proxiesPerPage);
    if (page < 1 || page > totalPages) return;
    
    currentPage = page;
    displayProxies();
    updatePagination();
    
    // Smooth scroll to top of proxy grid
    proxyGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// Search functionality
function searchProxies() {
    const searchTerm = searchInput.value.toLowerCase().trim();
    
    if (searchTerm === '') {
        filteredProxies = [...allProxies];
    } else {
        filteredProxies = allProxies.filter(proxy => 
            proxy.ip.includes(searchTerm) || 
            proxy.port.toString().includes(searchTerm)
        );
    }
    
    currentPage = 1;
    displayProxies();
    updatePagination();
    proxyCountEl.textContent = filteredProxies.length;
}

// Filter functionality
filterBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        filterBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        const filter = btn.dataset.filter;
        
        if (filter === 'all') {
            filteredProxies = [...allProxies];
        } else if (filter === 'fast') {
            // Filter by common fast proxy ports
            filteredProxies = allProxies.filter(proxy => 
                parseInt(proxy.port) < 10000
            );
        }
        
        currentPage = 1;
        displayProxies();
        updatePagination();
        proxyCountEl.textContent = filteredProxies.length;
    });
});

// Event listeners
searchBtn.addEventListener('click', searchProxies);
searchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') searchProxies();
});
refreshBtn.addEventListener('click', fetchProxies);

// Copy to clipboard functionality
function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
        showToast('‚úì Copied to clipboard!');
    });
}

function showToast(message) {
    const toast = document.createElement('div');
    toast.style.cssText = `
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        padding: 1rem 2rem;
        border-radius: 12px;
        z-index: 1000;
        animation: slideIn 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

// Initial load
fetchProxies();

// Auto-refresh every 5 minutes
setInterval(fetchProxies, 5 * 60 * 1000);