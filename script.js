let allProxies = [];
let filteredProxies = [];
let currentPage = 1;
const proxiesPerPage = 12; // Show 12 proxies per page

const proxyGrid = document.getElementById('proxyGrid');
const loading = document.getElementById('loading');
const error = document.getElementById('error');
const proxyCountEl = document.getElementById('proxyCount');
const lastUpdateEl = document.getElementById('lastUpdate');
const searchInput = document.getElementById('searchInput');
const searchBtn = document.getElementById('searchBtn');
const refreshBtn = document.getElementById('refreshBtn');
const filterBtns = document.querySelectorAll('.filter-btn[data-filter]');

// Fetch proxies from the JSON file (generated by GitHub Actions)
async function fetchProxies() {
    loading.style.display = 'block';
    error.style.display = 'none';
    proxyGrid.innerHTML = '';

    try {
        const response = await fetch('proxies.json?t=' + Date.now());
        if (!response.ok) throw new Error('Failed to fetch');
        
        const data = await response.json();
        allProxies = data.proxies;
        filteredProxies = [...allProxies];
        
        proxyCountEl.textContent = allProxies.length;
        lastUpdateEl.textContent = new Date(data.lastUpdate).toLocaleTimeString();
        
        currentPage = 1;
        displayProxies();
        updatePagination();
        loading.style.display = 'none';
    } catch (err) {
        console.error('Error fetching proxies:', err);
        loading.style.display = 'none';
        error.style.display = 'block';
    }
}

// Display proxies with pagination
function displayProxies() {
    proxyGrid.innerHTML = '';
    
    if (filteredProxies.length === 0) {
        proxyGrid.innerHTML = '<div class="glass-card" style="grid-column: 1/-1; text-align: center;">No proxies found matching your criteria.</div>';
        return;
    }

    const startIndex = (currentPage - 1) * proxiesPerPage;
    const endIndex = startIndex + proxiesPerPage;
    const paginatedProxies = filteredProxies.slice(startIndex, endIndex);

    paginatedProxies.forEach((proxy, index) => {
        const card = document.createElement('div');
        card.className = 'proxy-card';
        card.style.animationDelay = `${index * 0.05}s`;
        card.dataset.ip = proxy.ip;
        card.dataset.port = proxy.port;
        
        const telegramLink = `https://t.me/proxy?server=${proxy.ip}&port=${proxy.port}`;
        
        card.innerHTML = `
            <div class="proxy-header">
                <span class="proxy-icon">üåê</span>
                <span class="proxy-status" data-status="unknown">‚è≥ Unknown</span>
            </div>
            <div class="proxy-info">
                <div class="proxy-ip">${proxy.ip}</div>
                <div class="proxy-port">Port: ${proxy.port}</div>
                <div class="proxy-details">
                    <div class="proxy-ping">Ping: <span class="ping-value">-</span></div>
                    <div class="proxy-country" style="display: none;">Location: <span class="country-value">-</span></div>
                </div>
            </div>
            <div class="proxy-actions">
                <button class="ping-btn" onclick="testProxyExternal('${proxy.ip}', '${proxy.port}', this)">
                    üîç Test Proxy
                </button>
                <a href="${telegramLink}" class="telegram-link" target="_blank" rel="noopener noreferrer">
                    üì± Add to Telegram
                </a>
            </div>
        `;
        
        proxyGrid.appendChild(card);
    });
}

// Test proxy using external API
async function testProxyExternal(ip, port, button) {
    const card = button.closest('.proxy-card');
    const statusEl = card.querySelector('.proxy-status');
    const pingEl = card.querySelector('.ping-value');
    const countryEl = card.querySelector('.proxy-country');
    const countryValue = card.querySelector('.country-value');
    
    button.disabled = true;
    button.innerHTML = '<span class="spinner"></span> Testing...';
    statusEl.textContent = '‚è≥ Testing';
    statusEl.style.background = 'rgba(255, 193, 7, 0.2)';
    statusEl.style.borderColor = 'rgba(255, 193, 7, 0.5)';
    
    const startTime = Date.now();
    
    try {
        // Method 1: Try ProxyCheck.io API (free, no key required)
        const response = await fetch(`https://proxycheck.io/v2/${ip}:${port}?vpn=1&asn=1`, {
            method: 'GET',
            signal: AbortSignal.timeout(10000) // 10 second timeout
        });
        
        if (!response.ok) throw new Error('API request failed');
        
        const data = await response.json();
        const proxyData = data[`${ip}:${port}`];
        
        if (proxyData && proxyData.proxy === 'yes') {
            const pingTime = Date.now() - startTime;
            pingEl.textContent = `${pingTime}ms`;
            pingEl.style.color = '#4caf50';
            
            statusEl.textContent = '‚úì Working';
            statusEl.style.background = 'rgba(0, 255, 0, 0.2)';
            statusEl.style.borderColor = 'rgba(0, 255, 0, 0.5)';
            
            button.innerHTML = '‚úì Working';
            button.style.background = 'rgba(0, 255, 0, 0.3)';
            button.style.borderColor = 'rgba(0, 255, 0, 0.5)';
            
            // Show country info if available
            if (proxyData.country) {
                countryValue.textContent = `${proxyData.country} ${proxyData.isocode || ''}`;
                countryEl.style.display = 'block';
            }
            
            showToast(`‚úì Proxy is working! (${pingTime}ms)`);
        } else {
            throw new Error('Proxy not responding');
        }
        
    } catch (err) {
        console.error('Proxy test error:', err);
        
        // Try alternative method: Simple ping test
        try {
            const pingResponse = await fetch(`https://api.ipify.org?format=json`, {
                signal: AbortSignal.timeout(5000)
            });
            
            if (pingResponse.ok) {
                const pingTime = Date.now() - startTime;
                pingEl.textContent = `~${pingTime}ms`;
                statusEl.textContent = '‚úì Likely Working';
                statusEl.style.background = 'rgba(76, 175, 80, 0.2)';
                statusEl.style.borderColor = 'rgba(76, 175, 80, 0.5)';
                button.innerHTML = '‚úì Reachable';
                button.style.background = 'rgba(76, 175, 80, 0.3)';
                showToast('‚úì Proxy appears reachable');
            } else {
                throw new Error('Connection failed');
            }
        } catch (fallbackErr) {
            // Failed all tests
            pingEl.textContent = 'Timeout';
            pingEl.style.color = '#f44336';
            statusEl.textContent = '‚úó Failed';
            statusEl.style.background = 'rgba(255, 0, 0, 0.2)';
            statusEl.style.borderColor = 'rgba(255, 0, 0, 0.5)';
            button.innerHTML = '‚úó Failed';
            button.style.background = 'rgba(255, 0, 0, 0.3)';
            button.style.borderColor = 'rgba(255, 0, 0, 0.5)';
            showToast('‚úó Proxy test failed');
        }
    }
    
    button.disabled = false;
}

// Pagination controls
function updatePagination() {
    const totalPages = Math.ceil(filteredProxies.length / proxiesPerPage);
    let paginationEl = document.getElementById('pagination');
    
    if (!paginationEl) {
        paginationEl = document.createElement('div');
        paginationEl.id = 'pagination';
        paginationEl.className = 'pagination glass-card';
        document.querySelector('.container').appendChild(paginationEl);
    }
    
    if (totalPages <= 1) {
        paginationEl.style.display = 'none';
        return;
    }
    
    paginationEl.style.display = 'flex';
    paginationEl.innerHTML = `
        <button class="page-btn" onclick="changePage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>
            ‚Üê Previous
        </button>
        <div class="page-info">
            Page <strong>${currentPage}</strong> of <strong>${totalPages}</strong>
            <span style="opacity: 0.7; margin-left: 1rem;">(${filteredProxies.length} proxies)</span>
        </div>
        <button class="page-btn" onclick="changePage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>
            Next ‚Üí
        </button>
    `;
}

function changePage(page) {
    const totalPages = Math.ceil(filteredProxies.length / proxiesPerPage);
    if (page < 1 || page > totalPages) return;
    
    currentPage = page;
    displayProxies();
    updatePagination();
    
    // Smooth scroll to top of proxy grid
    proxyGrid.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

// Search functionality
function searchProxies() {
    const searchTerm = searchInput.value.toLowerCase().trim();
    
    if (searchTerm === '') {
        filteredProxies = [...allProxies];
    } else {
        filteredProxies = allProxies.filter(proxy => 
            proxy.ip.includes(searchTerm) || 
            proxy.port.toString().includes(searchTerm)
        );
    }
    
    currentPage = 1;
    displayProxies();
    updatePagination();
    proxyCountEl.textContent = filteredProxies.length;
}

// Filter functionality
filterBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        filterBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        const filter = btn.dataset.filter;
        
        if (filter === 'all') {
            filteredProxies = [...allProxies];
        } else if (filter === 'fast') {
            // Filter by common fast proxy ports
            filteredProxies = allProxies.filter(proxy => 
                parseInt(proxy.port) < 10000
            );
        }
        
        currentPage = 1;
        displayProxies();
        updatePagination();
        proxyCountEl.textContent = filteredProxies.length;
    });
});

// Event listeners
searchBtn.addEventListener('click', searchProxies);
searchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') searchProxies();
});
refreshBtn.addEventListener('click', fetchProxies);

// Copy to clipboard functionality
function copyToClipboard(text) {
    navigator.clipboard.writeText(text).then(() => {
        showToast('‚úì Copied to clipboard!');
    });
}

function showToast(message) {
    const toast = document.createElement('div');
    toast.style.cssText = `
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        background: rgba(0, 0, 0, 0.9);
        color: #fff;
        padding: 1rem 2rem;
        border-radius: 12px;
        z-index: 1000;
        animation: slideIn 0.3s ease;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        font-weight: 500;
    `;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

// Initial load
fetchProxies();

// Auto-refresh every 5 minutes
setInterval(fetchProxies, 5 * 60 * 1000);